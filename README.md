#Sprint 3.

# Задание 1 Анализ и проектирование
 Задание состоит из четырёх частей, в которых нужно проанализировать текущее монолитное приложение, 
 выделить микросервисы и спроектировать взаимодействие между ними, 
 визуализируровать архитектуру с помощью инструмента С4, а затем разработать ER-диаграмму. 

## Решение подзаданий 1.1, 1.2, 1.3, 1.4 - находится в проекте Sprint3_Task_1_2_3_4.

## Подзадание 1.1 Анализ и планирование
Описание:

Диаграмма контекста — Context diagram
Диаграмма предоставляет общий обзор системы и её границ. Она показывает систему в окружении, выделяя основные внешние системы и пользователей, которые взаимодействуют с ней.


Изучена функциональность монолитного приложения:
Управление отоплением:
Пользователи могут удалённо включать/выключать отопление в своих домах.
Пользователи могут устанавливать желаемую температуру.
Система автоматически поддерживает заданную температуру, регулируя подачу тепла.
Мониторинг температуры:
Система получает данные о температуре с датчиков, установленных в домах.
Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.
Проанализируйте архитектуру монолитного приложения:
Язык программирования: Java
База данных: PostgreSQL
Архитектура: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
Взаимодействие: Синхронное, запросы обрабатываются последовательно.
Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
Развертывание: Требует остановки всего приложения.
Определены домены и границы контекстов: домен «Управление Устройствами», «Управление Телеметрией».
Визуализирован контекст системы. Создана C4 диаграмма (System Context diagram) с помощью PlantUML, чтобы наглядно показать, как монолитное приложение взаимодействует с внешним миром (пользователи, датчики).

### Диаграмма - 1-1.puml
Система - управление устройствами и мониторинг телеметрии.

Описание системы и её окружения.
Участники: User(пользователи), Admin(администраторы).
Домены - ManageDevice(управление устройством), ManageTelemetry(управление телеметрией).
База данных - Database(база данных - PostgreSQL).
Внешнии системы - Sensors(сенсоры).


## Подзадание 1.2 Архитектура микросервисов
Описание:

Диаграмма контейнеров — Container diagram
Диаграмма контейнеров показывает основные высокоуровневые контейнеры системы и взаимодействия между ними. Например, веб-приложения, базы данных, микросервисы.

Диаграмма компонентов — Component diagram
Диаграмма компонентов углубляется в один из контейнеров, показывая, из каких компонентов он состоит и как эти компоненты взаимодействуют друг с другом.

Cпроектирована высокоуровневую архитектуру новой системы, основанная на микросервисах. 
Определены ключевые микросервисы, спроектировано их взаимодействие с учетом использования API Gateway и Kafka, а также визуализирована полученная архитектура с помощью диаграмм C4.

Произведена декомпозиция на микросервисы. Основываясь на выделенных доменах и границах контекстов (подзадание 1.1) и бизнес-целях.
Разбита система на новые микросервисы, учитывая наилучшие практики архитектуры микросервисов и паттерны проектирования.
Определены взаимодействия между:
микросервисами,
API Gateway,
шиной данных (Kafka),
базой данных.

Система разбита на микросервисы в соответствии с выделенными доменами и границами контекстов.
Определено взаимодействие между микросервисами, API Gateway, шиной данных (Kafka) и базой данных.
Созданы C4 диаграммы на уровне контейнеров (Containers) и компонентов (Components), визуализирована архитектура системы.
Все диаграммы созданы с использованием PlantUML и соответствуют стандартам C4.

Определены ключевые микросервисы и спроектировано их взаимодействие с использованием API Gateway и Kafka. 

### Диаграмма - 1-2_Conteiner.puml, 
Система - управление устройствами и мониторинг телеметрии.

Описание системы и её окружения.
Участники: User(пользователи), Admin(администраторы).
Api - ApiGateWay.
Шина данных (Kafka).
Микросервисы - ManageDeviceService(управление устройством), ManageTelemetryService(управление телеметрией).
База данных - Database(база данных - PostgreSQL).
Внешнии системы - ApiSensors(сенсоры).

### Диаграмма - 1-2_component.puml, детальное описание сервиса управление устройствами.
Выбран контейнер ManageDevice - управление устройствами и детализирована его внутренняя структура.
Определины основные компоненты внутри контейнера и их взаимодействие.
На этом уровне мы детализируем компоненты внутри веб-приложения FitLife. На диаграмме компонентов нужно показать:

Service Layer — слой бизнес-логики.
Repository Layer — слой доступа к данным.

AuthController - компонент, который обрабатывает аутентификацию и авторизацию пользователей, 
CommandHandlerController - компонент, который обрабатывает команды для управления устройствами, 
DeviceStatusManagerController - компонент, который управляет статусом устройств, 
ApiController - компонент, который взаимодействует с api,

взаимодействуют:
с ServiceLayer,
далее вызов RepositoryLayer,
затем вызов Database.

## Подзадание 1.3 ER-диаграмма
Описание:

Диаграмма кода — Code/classes diagram
Диаграмма кода отображает структуру кода в рамках одного из компонентов. Показывая классы или файлы и их взаимодействие.

Описание диаграммы:
Детализирован код компонентов устройств и телеметрии.
Показаны основные классы или файлы и их взаимодействие.
На диаграмме нужно показать:

Определены ключевые сущности (такие как «Устройство», «Модуль», «Пользователь», «Телеметрия») и смоделировать их взаимосвязи, 
чтобы создать логическую модель базы данных.

Идентификация сущностей: На основе анализа предметной области и спроектированных микросервисов, определены основные сущности системы. 
Примеры сущностей:

Пользователь (User). 
Атрибуты:
  +Integer id
  +String name
  +String email
  +List<Membership> memberships  
Методы:
  +void register()
  +void login()

Дом (House).
Атрибуты:
  +Integer id
  +Integer number
  +Integer user_id

Устройство (Device). 
Атрибуты:
+Integer id
  +Integer type_id
  +Integer house_id
  +Integer serial_number
  +bool status  
Методы:
  +Device get_deviceinfo()
  +Device get_status()
  +Device set_status()
  +Telemetry get_telemetry()
  +void set_telemetry()
  +Telemetry get_historytelemetry()

Тип устройства (DeviceType).
Атрибуты:
  +Integer id
  +String name

Модуль (Module). 
Атрибуты:
  +Integer id
  +Date Name
  +Integer device_id

Телеметрия (Telemetry). 
Атрибуты:
  +Integer id
  +Integer device_id
  +Integer temperature
  +Date date  
Методы:
  +void get_telemetry()
  +void set_telemetry()
  +Integer get_temperature()
  +void set_temperature()
  +Telemetry get_historytelemetry()

Определены основные сущности системы, например как «Пользователь», «Дом», «Устройство», «Тип устройства», «Модуль» и «Телеметрия».
Для каждой сущности определены необходимые атрибуты.
Описаны связи между сущностями (один-к-одному, один-ко-многим, многие-ко-многим).
Создана ER-диаграмма с использованием PlantUML.
ER-диаграмма корректно отображает все сущности, их атрибуты и связи между ними.

### Диаграмма - 1-3.puml.
Система - взаимодействия сущностей.
Сушности: User, House, Device, Telemetry, DeviceType, Module.

Взаимодействие сущностей,
User "1" -- "0..*" House : has - связь один ко многим
House "1" -- "0..*" Device : includes - связь один ко многим
Device "1" -- "0..*" Telemetry : has - связь один ко многим
DeviceType "1" -- "0..*" Device : has -  связь один ко многим
Device "1" -- "0..*" Module : has - связь один ко многим


## Подзадание 1.4 Создание и документирование API
Описание:

OpenAPI vs AsyncAPI
Документация и стандартизация API — важные аспекты разработки микросервисных архитектур. OpenAPI и AsyncAPI — два популярных стандарта, которые помогают разработчикам описывать синхронные и асинхронные API соответственно. 

OpenAPI — это спецификация для описания RESTful API, которая позволяет разработчикам документировать эндпоинты, методы, параметры и ответы API. OpenAPI широко используется для описания синхронных взаимодействий между сервисами.
Плюсы использования OpenAPI:
Улучшенная документация: стандартизированный формат позволяет легко документировать и понимать структуру API.
Инструменты и генерация кода: существуют многочисленные инструменты для автоматической генерации кода, клиентских библиотек и документации на основе спецификаций OpenAPI.
Совместимость: поддержка различных протоколов HTTP и интеграция с популярными платформами и фреймворками.

AsyncAPI — это спецификация для документирования и проектирования асинхронных API. Подобно OpenAPI для синхронных API, AsyncAPI позволяет описывать структуры сообщений, каналы и взаимодействия между компонентами в асинхронной системе.
Плюсы использования AsyncAPI:
Улучшенная документация: стандартизированный формат позволяет легко документировать и понимать структуру и взаимодействие асинхронных систем.
Инструменты и генерация кода: существуют инструменты для автоматической генерации кода, клиентских библиотек и документации на основе спецификаций AsyncAPI.
Совместимость: поддержка различных протоколов и брокеров сообщений — Kafka, MQTT, AMQP.

Kafka для асинхронного обмена
Apache Kafka — это распределённая стриминговая платформа, разработанная для публикации, подписки, хранения и обработки потоков данных в реальном времени. 

Без Kafka данные от сенсоров обрабатываются синхронно. Это приводит к задержкам, особенно при высоком потоке данных, снижает актуальность информации для пользователей.

Kafka позволяет обрабатывать данные в режиме реального времени, распределяя нагрузку и обеспечивая быструю передачу данных между источниками и потребителями.
Масштабируемость

При увеличении объёма данных и числа пользователей начинаются проблемы с производительностью и масштабируемостью. Традиционные методы синхронного взаимодействия  несправляются с нагрузкой.

Что нужно сделать?
Выбор типов API: В зависимости от специфики взаимодействия между вашими микросервисами, вы можете использовать:
REST API: Хорошо подходит для синхронного взаимодействия, когда клиенту (в данном случае — другому микросервису) нужен немедленный ответ на запрос.
AsyncAPI: Используется для асинхронного взаимодействия, когда клиенту не нужно ждать ответа немедленно (например, отправка уведомления о новом измерении температуры).

Проектирование API для микросервиса «Управление устройствами». Например, определите эндпойнты и методы запросов для выполнения основных операций:
Получение информации об устройстве:
Эндпойнт: /devices/{device_id}
Метод: GET
Описание: Возвращает подробную информацию о конкретном устройстве по его ID.
Обновление состояния устройства:
Эндпойнт: /devices/{device_id}/status
Метод: PUT
Описание: Позволяет изменить состояние устройства (например, включить/выключить).
Отправка команды устройству:
Эндпойнт: /devices/{device_id}/commands
Метод: POST
Описание: Отправляет команду устройству (например, «установить температуру 22 градуса»).
Проектирование API для микросервиса «Телеметрия»
Получение последних данных телеметрии:
Эндпойнт: /devices/{device_id}/telemetry/latest
Метод: GET
Описание: Возвращает последнее полученное значение телеметрии для устройства.
Получение исторических данных телеметрии:
Эндпойнт: /devices/{device_id}/telemetry
Метод: GET
Описание: Возвращает исторические данные телеметрии для устройства за определённый период времени.

### 1-4_Api.yaml.

Используется две сущности.

(Устройство)
Device{
id*	integer($int64)
example: 10
type_id	integer($int64)
example: 11
house_id	integer($int64)
example: 12
serial_number	integer($int64)
example: 13
}

(Телеметрия)
Telemetry{
id*	integer($int64)
example: 10
device_id*	integer($int64)
example: 11
temperature*	integer($int64)
example: 12
date*	string($date-time)
example: 2020-10-15 14:10:38
}

# Задание 2: Разработка MVP

## Подзадание 2.1 Новые микросервисы и интеграция с монолитом
Описание:

Решение задания 2.1 находится в проектах DeviceService, TelemetryService.

Настройка кластера Kafka
Настройка кластера Kafka включает установку и конфигурацию необходимых компонентов (Kafka и ZooKeeper), а также создание и управление топиками. Ниже шаги по настройке кластера Kafka и интеграции его с микросервисами.
Шаг 1. Установка Kafka и ZooKeeper
Скачайте последнюю версию Apache Kafka с официального сайта: Kafka Downloads. Распакуйте архив в удобное место на вашем сервере или локальной машине.
 tar -xzf kafka_2.13-2.8.0.tgz
 cd kafka_2.13-2.8.0
  
ZooKeeper необходим для координации и управления кластером Kafka. Конфигурационный файл ZooKeeper находится в config/zookeeper.properties.
 # Start ZooKeeper
 bin/zookeeper-server-start.sh config/zookeeper.properties
  
Основной конфигурационный файл Kafka находится в config/server.properties. Убедитесь, что все необходимые параметры настроены, включая ID брокера, директорию хранения логов и адрес ZooKeeper.
 # Start Kafka Broker
 bin/kafka-server-start.sh config/server.properties
  
Шаг 2. Запуск ZooKeeper и Kafka
Запустите ZooKeeper с использованием предоставленного скрипта.
 bin/zookeeper-server-start.sh config/zookeeper.properties
  
После запуска ZooKeeper запустите Kafka-брокер.
 bin/kafka-server-start.sh config/server.properties
  
Шаг 3. Создание топиков
Используйте команду kafka-topics.sh для создания нового топика. Укажите параметры — имя топика, количество разделов и фактор репликации (англ. replication factor).
 bin/kafka-topics.sh --create --topic weather-data --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1
  
Проверьте, что топик был успешно создан.
 bin/kafka-topics.sh --list --bootstrap-server localhost:9092
  
Команда --describe позволяет получить подробную информацию о топике, включая количество разделов, фактор репликации и статус разделов.
 bin/kafka-topics.sh --describe --topic my-topic --bootstrap-server localhost:9092
  
Топики в Kafka могут быть настроены с различными параметрами для оптимизации производительности и надёжности. 
 Некоторые из наиболее важных параметров:
retention.ms:
  
Определяет время хранения сообщений в топике.
Пример: хранить сообщения в течение 7 дней (604800000 миллисекунд).
  bin/kafka-topics.sh --alter --topic my-topic --config retention.ms=604800000 --bootstrap-server localhost:9092
   
cleanup.policy:
  
Определяет политику очистки сообщений (например, удаление старых сообщений или компактирование).
Пример: настроить политику очистки на удаление (delete).
  bin/kafka-topics.sh --alter --topic my-topic --config cleanup.policy=delete --bootstrap-server localhost:9092
   
min.insync.replicas:
  
Определяет минимальное количество реплик, которые должны подтвердить запись, прежде чем продюсер получит подтверждение.
Пример: установить минимальное количество реплик на 2.
  bin/kafka-topics.sh --alter --topic my-topic --config min.insync.replicas=2 --bootstrap-server localhost:9092
   
Разделы позволяют распределять данные топика по нескольким брокерам для обеспечения параллельной обработки и масштабируемости.
 
Вы можете добавить разделы к существующему топику с помощью команды --alter.
     bin/kafka-topics.sh --alter --topic my-topic --partitions 5 --bootstrap-server localhost:9092
      
 -alter: указывает, что необходимо изменить существующий топик.
 -partitions: новое количество разделов.
Для эффективного использования ресурсов кластера важно обеспечить равномерное распределение разделов по брокерам. Команда kafka-reassign-partitions.sh помогает в балансировке разделов.
  bin/kafka-reassign-partitions.sh --generate --zookeeper localhost:2181 --topics-to-move-json-file topics-to-move.json --broker-list "0,1,2"
   
-generate: генерирует план переассигнования разделов.
-zookeeper: адрес сервера ZooKeeper.
-topics-to-move-json-file: файл JSON, содержащий список топиков для переассигнования.
-broker-list: список брокеров, среди которых будут распределены разделы.

1. Настройка продюсера
Продюсеры публикуют сообщения в топики Kafka. Настройка продюсера включает установку зависимостей, конфигурацию и написание кода для отправки сообщений.
Установка зависимостей
Включите зависимости Kafka в ваш проект. Для Maven используйте следующий фрагмент pom.xml:
<dependency>
    <groupId>org.apache.kafka</groupId>
    <artifactId>kafka-clients</artifactId>
    <version>2.8.0</version>
</dependency> 
Конфигурация продюсера
Настройте параметры продюсера — адреса брокеров, сериализаторы ключей и значений.
Properties props = new Properties();
props.put("bootstrap.servers", "localhost:9092");
props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

Producer<String, String> producer = new KafkaProducer<>(props); 
2. Настройка консьюмера
Консьюмеры подписываются на топики Kafka и обрабатывают сообщения. Настройка консьюмера включает установку зависимостей, конфигурацию и написание кода для чтения сообщений.
Установка зависимостей
Включите зависимости Kafka в ваш проект. Для Maven используйте следующий фрагмент pom.xml:
<dependency>
    <groupId>org.apache.kafka</groupId>
    <artifactId>kafka-clients</artifactId>
    <version>2.8.0</version>
</dependency> 
Конфигурация консьюмера
Настройте параметры консьюмера — адреса брокеров, десериализаторы ключей и значений, идентификатор группы консьюмеров.
Properties props = new Properties();
props.put("bootstrap.servers", "localhost:9092");
props.put("group.id", "weather-consumers");
props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");

Consumer<String, String> consumer = new KafkaConsumer<>(props);
consumer.subscribe(Arrays.asList("weather-data")); 
3. Отправка и получение сообщений
1. Публикация данных сенсоров (Sensors aka SensorProducer)
Сенсоры отправляют данные о погоде в топик Kafka. Продюсер публикует сообщения с данными о температуре, влажности и других параметрах.
ProducerRecord<String, String> record = new ProducerRecord<>("weather-data", "sensor1", "temperature=25,humidity=60");
producer.send(record);
producer.close(); 
2. Обработка данных и уведомления (DataProcessor и NotificationService aka DataProcessorConsumer и NotificationConsumer)
Сервис обработки данных считывает данные из топика, обрабатывает их и публикует результаты в новый топик. Сервис уведомлений подписывается на этот топик и отправляет уведомления пользователям.
// Консьюмер для обработки данных
Consumer<String, String> dataConsumer = new KafkaConsumer<>(props);
dataConsumer.subscribe(Arrays.asList("weather-data"));
while (true) {
    ConsumerRecords<String, String> records = dataConsumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord<String, String> record : records) {
        // Обработка данных
        String processedData = processData(record.value());
        // Публикация обработанных данных
        ProducerRecord<String, String> processedRecord = new ProducerRecord<>("processed-weather-data", record.key(), processedData);
        producer.send(processedRecord);
    }
}

// Консьюмер для уведомлений
Consumer<String, String> notificationConsumer = new KafkaConsumer<>(props);
notificationConsumer.subscribe(Arrays.asList("processed-weather-data"));
while (true) {
    ConsumerRecords<String, String> records = notificationConsumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord<String, String> record : records) {
        // Отправка уведомлений
        sendNotification(record.value());
    }
} 

Созданыдва новых микросервиса: «Управление телеметрией» и «Управление устройствами». Эти микросервисы будут выполнять базовые функции, соответствующие своим названиям, и интегрироваться с существующим монолитным приложением. 
Микросервис «Управление телеметрией»: Ответственен за приём, обработку и хранение данных телеметрии от устройств.
Микросервис «Управление устройствами»: Отвечает за регистрацию новых устройств, управление их состоянием (вкл/выкл) и отправку команд.
Взаимодействие между микросервисами и монолитом будет осуществляться через шину данных Kafka, что позволит постепенно переносить функциональность из монолита в микросервисы.


### Запросы для postman

(GET)
/devices/10

(PUT)
/devices/10/status
{
  "id": 10,
  "type_id": 11,
  "house_id": 12,
  "serial_number": 13
}

(POST)
/devices/10/commands
{
  "id": 10,
  "device_id": 11,
  "temperature": 12,
  "date": "2020-10-15 14:10:38"
}


(GET)
/devices/10/telemetry/latest

(GET)
/devices/10/telemetry


(Описание сущности)
Device{
id*	integer($int64)
example: 10
type_id	integer($int64)
example: 11
house_id	integer($int64)
example: 12
serial_number	integer($int64)
example: 13
}

(Описание сущности)
Telemetry{
id*	integer($int64)
example: 10
device_id*	integer($int64)
example: 11
temperature*	integer($int64)
example: 12
date*	string($date-time)
example: 2020-10-15 14:10:38
}


### Запустить проект
docker compose up -d
http://localhost:8080/ - запускается swagger для тестирования.